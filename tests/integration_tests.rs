use ansi_term::{Color, Style};
use gambit::MutateParams;
use project_root::get_project_root;
use serde_json;
use std::{collections::HashSet, env, error, path::PathBuf};

/// All test cases are generated by running Gambit on the individual files
/// listed in `all.gconf` and then using `scripts/mutants_log_to_regression.py`
/// to print `gambit_out/mutants.log` as regression test cases
#[test]
fn test_all() {
    assert_exact_mutants_from_json(
        "all.gconf",
        &vec![
            ("BinaryOpMutation", "+", "-", (7, 10)),
            ("BinaryOpMutation", "+", "*", (7, 10)),
            ("BinaryOpMutation", "+", "/", (7, 10)),
            ("BinaryOpMutation", "+", "%", (7, 10)),
            ("BinaryOpMutation", "+", "**", (7, 10)),
            ("BinaryOpMutation", "-", "+", (11, 10)),
            ("BinaryOpMutation", "-", "*", (11, 10)),
            ("BinaryOpMutation", "-", "/", (11, 10)),
            ("BinaryOpMutation", "-", "%", (11, 10)),
            ("BinaryOpMutation", "-", "**", (11, 10)),
            ("BinaryOpMutation", "*", "+", (15, 10)),
            ("BinaryOpMutation", "*", "-", (15, 10)),
            ("BinaryOpMutation", "*", "/", (15, 10)),
            ("BinaryOpMutation", "*", "%", (15, 10)),
            ("BinaryOpMutation", "*", "**", (15, 10)),
            ("BinaryOpMutation", "/", "+", (19, 10)),
            ("BinaryOpMutation", "/", "-", (19, 10)),
            ("BinaryOpMutation", "/", "*", (19, 10)),
            ("BinaryOpMutation", "/", "%", (19, 10)),
            ("BinaryOpMutation", "/", "**", (19, 10)),
            ("BinaryOpMutation", "%", "+", (23, 10)),
            ("BinaryOpMutation", "%", "-", (23, 10)),
            ("BinaryOpMutation", "%", "*", (23, 10)),
            ("BinaryOpMutation", "%", "/", (23, 10)),
            ("BinaryOpMutation", "%", "**", (23, 10)),
            ("BinaryOpMutation", "**", "+", (27, 10)),
            ("BinaryOpMutation", "**", "-", (27, 10)),
            ("BinaryOpMutation", "**", "*", (27, 10)),
            ("BinaryOpMutation", "**", "/", (27, 10)),
            ("BinaryOpMutation", "**", "%", (27, 10)),
            ("RequireMutation", "cond1", "true", (7, 10)),
            ("RequireMutation", "cond1", "false", (7, 10)),
            ("RequireMutation", "cond2", "true", (8, 10)),
            ("RequireMutation", "cond2", "false", (8, 10)),
            ("RequireMutation", "cond3", "true", (9, 10)),
            ("RequireMutation", "cond3", "false", (9, 10)),
            ("AssignmentMutation", "42", "0", (13, 6)),
            ("AssignmentMutation", "42", "1", (13, 6)),
            ("AssignmentMutation", "13", "0", (14, 6)),
            ("AssignmentMutation", "13", "1", (14, 6)),
            ("AssignmentMutation", "3110", "0", (15, 6)),
            ("AssignmentMutation", "3110", "1", (15, 6)),
            ("AssignmentMutation", "true", "false", (16, 6)),
            ("AssignmentMutation", "false", "true", (17, 6)),
            (
                "DeleteExpressionMutation",
                "result ++",
                "assert(true)",
                (10, 6),
            ),
            ("DeleteExpressionMutation", "i++", "assert(true)", (9, 29)),
            ("IfStatementMutation", "a", "true", (7, 6)),
            ("IfStatementMutation", "a", "false", (7, 6)),
            ("SwapArgumentsOperatorMutation", "x - y", "y - x", (7, 9)),
            ("SwapArgumentsOperatorMutation", "x / y", "y / x", (11, 9)),
            ("SwapArgumentsOperatorMutation", "x % y", "y % x", (15, 9)),
            ("SwapArgumentsOperatorMutation", "x ** y", "y ** x", (19, 9)),
            ("SwapArgumentsOperatorMutation", "x > y", "y > x", (23, 9)),
            ("SwapArgumentsOperatorMutation", "x < y", "y < x", (27, 9)),
            ("SwapArgumentsOperatorMutation", "x >= y", "y >= x", (31, 9)),
            ("SwapArgumentsOperatorMutation", "x <= y", "y <= x", (35, 9)),
            ("SwapArgumentsOperatorMutation", "x << y", "y << x", (39, 9)),
            ("SwapArgumentsOperatorMutation", "x >> y", "y >> x", (43, 9)),
            ("UnaryOperatorMutation", "~", "++", (7, 9)),
            ("UnaryOperatorMutation", "~", "--", (7, 9)),
            ("UnaryOperatorMutation", "++", "--", (11, 9)),
            ("UnaryOperatorMutation", "++", "~", (11, 9)),
            ("UnaryOperatorMutation", "--", "++", (15, 9)),
            ("UnaryOperatorMutation", "--", "~", (15, 9)),
            ("UnaryOperatorMutation", "++", "--", (19, 3)),
            ("UnaryOperatorMutation", "--", "++", (24, 3)),
            ("ElimDelegateMutation", "delegatecall", "call", (25, 55)),
        ],
    );
}

#[test]
fn multiple_contracts_1() {
    assert_exact_mutants_from_json(
        "multiple-contracts-1.gconf",
        &vec![
            //C.get10PowerDecimals
            (
                "DeleteExpressionMutation",
                "assert(c[0] == e)",
                "assert(true)",
                (7, 9),
            ),
            ("BinaryOpMutation", "**", "+", (26, 24)),
            ("BinaryOpMutation", "**", "-", (26, 24)),
            ("BinaryOpMutation", "**", "*", (26, 24)),
            ("BinaryOpMutation", "**", "/", (26, 24)),
            ("BinaryOpMutation", "**", "%", (26, 24)),
            (
                "SwapArgumentsOperatorMutation",
                "a ** decimals",
                "decimals ** a",
                (26, 23),
            ),
            (
                "DeleteExpressionMutation",
                "assert(c[0] == e)",
                "assert(true)",
                (31, 9),
            ),
        ],
    )
}

#[test]
fn multiple_contracts_2() {
    assert_exact_mutants_from_json(
        "multiple-contracts-2.gconf",
        &vec![
            /* Utils.add */
            ("BinaryOpMutation", "+", "-", (11, 17)),
            ("BinaryOpMutation", "+", "*", (11, 17)),
            ("BinaryOpMutation", "+", "/", (11, 17)),
            ("BinaryOpMutation", "+", "%", (11, 17)),
            /* C.get10PowerDecimals */
            ("BinaryOpMutation", "**", "+", (26, 24)),
            ("BinaryOpMutation", "**", "-", (26, 24)),
            ("BinaryOpMutation", "**", "*", (26, 24)),
            ("BinaryOpMutation", "**", "/", (26, 24)),
            ("BinaryOpMutation", "**", "%", (26, 24)),
            (
                "SwapArgumentsOperatorMutation",
                "a ** decimals",
                "decimals ** a",
                (26, 23),
            ),
        ],
    )
}

#[test]
fn multiple_contracts_3() {
    assert_exact_mutants_from_json(
        "multiple-contracts-3.gconf",
        &vec![
            /* Utils.getarray */
            /* Utils.add */
            (
                "DeleteExpressionMutation",
                "assert(c[0] == e)",
                "assert(true)",
                (7, 9),
            ),
            ("BinaryOpMutation", "+", "-", (11, 17)),
            ("BinaryOpMutation", "+", "*", (11, 17)),
            ("BinaryOpMutation", "+", "/", (11, 17)),
            ("BinaryOpMutation", "+", "%", (11, 17)),
            (
                "DeleteExpressionMutation",
                "a[0] = msg.sender",
                "assert(true)",
                (20, 9),
            ),
            /* C.get10PowerDecimals */
            ("BinaryOpMutation", "**", "+", (26, 24)),
            ("BinaryOpMutation", "**", "-", (26, 24)),
            ("BinaryOpMutation", "**", "*", (26, 24)),
            ("BinaryOpMutation", "**", "/", (26, 24)),
            ("BinaryOpMutation", "**", "%", (26, 24)),
            (
                "SwapArgumentsOperatorMutation",
                "a ** decimals",
                "decimals ** a",
                (26, 23),
            ),
            (
                "DeleteExpressionMutation",
                "assert(c[0] == e)",
                "assert(true)",
                (31, 9),
            ),
            (
                "DeleteExpressionMutation",
                "Utils.getarray(b, address(this))",
                "assert(true)",
                (36, 9),
            ),
            /* C.getarray */
            /* C.callmyself */
            /* C.add */
            (
                "DeleteEmitMutation",
                "emit Called()",
                "assert(true)",
                (37, 9),
            ),
            ("BinaryOpMutation", "+", "-", (41, 17)),
            ("BinaryOpMutation", "+", "*", (41, 17)),
            ("BinaryOpMutation", "+", "/", (41, 17)),
            ("BinaryOpMutation", "+", "%", (41, 17)),
        ],
    )
}

#[test]
fn multiple_contracts_4() {
    assert_exact_mutants_from_json(
        "multiple-contracts-4.gconf",
        &vec![
            /* Utils.getarray */
            /* Utils.add */
            ("BinaryOpMutation", "+", "-", (11, 17)),
            ("BinaryOpMutation", "+", "*", (11, 17)),
            ("BinaryOpMutation", "+", "/", (11, 17)),
            ("BinaryOpMutation", "+", "%", (11, 17)),
            /* C.get10PowerDecimals */
            /* C.getarray */
            /* C.callmyself */
            /* C.add */
            ("BinaryOpMutation", "+", "-", (41, 17)),
            ("BinaryOpMutation", "+", "*", (41, 17)),
            ("BinaryOpMutation", "+", "/", (41, 17)),
            ("BinaryOpMutation", "+", "%", (41, 17)),
        ],
    )
}

/// Assert the expected mutations of JSON configuration file located in
/// `benchmarks/config-jsons`.
///
/// The expected mutants can be order independent: we check that the actual and
/// expected mutants have the same number and are the same when put into a set
///
/// _(note: the length check on actuals and expected is maybe a little redundant,
/// but this checks against the same mutant being generated multiple times,
/// which will not show up when the mutants are stored in sets for equality
/// checking)_
///
/// # Arguments
///
/// * `json` - name of the json file located in `Gambit/benchmarks/config-jsons`
/// * `expected` - a tuple describing the expected mutants. These tuples have
///   the form `(op, orig, repl, (linenum, colnum))`,
///   where
///   - `op` is the name of mutation operator derived from
///     `MutationType::toString()`
///   - `orig` is the source text of the node being replaced (corresponding to
///     `Mutant.orig`)
///   - `repl` is the source text replacing `orig` during mutation
///     (corresponding to `Mutant.repl`)
///   - `(linenum, colnum)` are the line and column numbers where the mutation
///     took place (corresponding to `Mutant.get_line_column`); we use this
///     information to disambiguate different mutations of similar nodes
fn assert_exact_mutants_from_json(json: &str, expected: &Vec<(&str, &str, &str, (usize, usize))>) {
    if let Ok(mutate_params) = get_config_json(json) {
        let results = gambit::run_mutate(mutate_params);
        assert!(results.is_ok());
        let dir_to_mutants = results.unwrap();
        assert_eq!(
            dir_to_mutants.keys().len(),
            1,
            "Expected a single output directory"
        );
        let mutants = dir_to_mutants.values().next().unwrap();
        let actuals: Vec<(String, &str, &str, (usize, usize))> = mutants
            .iter()
            .map(|m| {
                (
                    m.op.to_string(),
                    m.orig.trim(),
                    m.repl.trim(),
                    m.source.get_line_column(m.start).unwrap(),
                )
            })
            .collect();
        let actuals: Vec<(&str, &str, &str, (usize, usize))> = actuals
            .iter()
            .map(|(a, b, c, d)| (a.as_str(), *b, *c, *d))
            .collect();
        assert_eq!(
            expected.len(),
            actuals.len(),
            "\n{} Error: {}: expected {} mutants but found {}.\n    {} {}\n    {}   {}\n",
            Color::Red.bold().paint("[ ! ]"),
            Style::new().bold().underline().italic().paint(json),
            Color::Green.bold().paint(expected.len().to_string()),
            Color::Red.bold().paint(actuals.len().to_string()),
            Color::Green.bold().paint("Expected Mutants:"),
            expected
                .iter()
                .map(|(op, orig, repl, (line, col))| format!(
                    "[{}: `{}` -> `{}` ({}:{})]",
                    op, orig, repl, line, col
                ))
                .collect::<Vec<String>>()
                .join(", "),
            Color::Red.bold().paint("Actual Mutants:"),
            actuals
                .iter()
                .map(|(op, orig, repl, (line, col))| format!(
                    "[{}: `{}` -> `{}` ({}:{})]",
                    op, orig, repl, line, col
                ))
                .collect::<Vec<String>>()
                .join(", ")
        );

        let actuals: HashSet<(&str, &str, &str, (usize, usize))> =
            actuals.iter().cloned().collect();
        let expected: HashSet<(&str, &str, &str, (usize, usize))> =
            expected.iter().cloned().collect();
        assert_eq!(
            expected,
            actuals,
            "\n{} Error: {}\n",
            Color::Red.bold().paint("[ ! ]"),
            Style::new().bold().underline().italic().paint(json),
        );
    } else {
        assert!(false, "Couldn't read {}", json);
    }
}

fn get_config_json(config_json: &str) -> Result<Vec<MutateParams>, Box<dyn error::Error>> {
    let cwd = env::current_dir()?;
    let project_root = get_project_root()?;
    let path_to_config_json = project_root
        .join("benchmarks")
        .join("config-jsons")
        .join(config_json);
    let p = path_to_config_json.strip_prefix(&cwd).unwrap();
    let json_contents = std::fs::read_to_string(&p)?;
    let json: serde_json::Value = serde_json::from_reader(json_contents.as_bytes())?;

    let mut mutate_params: Vec<MutateParams> = if json.is_array() {
        serde_json::from_str(&json_contents)?
    } else if json.is_object() {
        let single_param: MutateParams = serde_json::from_str(&json_contents)?;
        vec![single_param]
    } else {
        panic!("Invalid configuration file: must be an array or an object")
    };
    // We also have to include some path update logic: a config file
    // uses paths relative to the parent directory of the config file.
    // This may be different than the current working directory, so we
    // need to compute paths as offsets from the config's parent
    // directory.
    let pb = PathBuf::from(&p);
    let json_parent_directory = pb.parent().unwrap();
    let base_outdir = PathBuf::from("gambit_tests_out");
    let base_outdir = base_outdir.join(format!("test_{}", config_json));

    for params in mutate_params.iter_mut() {
        // Update outdir
        let outdir = base_outdir.join(&params.outdir.clone().unwrap_or("gambit_out".to_string()));
        params.outdir = Some(outdir.to_str().unwrap().to_string());
        params.filename = params.filename.clone().map(|fnm| {
            json_parent_directory
                .join(fnm)
                .to_str()
                .unwrap()
                .to_string()
        });
        // Update overwrite
        params.no_overwrite = false;
    }

    Ok(mutate_params)
}
